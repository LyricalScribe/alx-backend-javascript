'use strict';

<<<<<<< HEAD
var _jestMatcherUtils = require('jest-matcher-utils');

var matcherUtils = _interopRequireWildcard(_jestMatcherUtils);

var _utils = require('./utils');

var _matchers = require('./matchers');

var _matchers2 = _interopRequireDefault(_matchers);

var _spy_matchers = require('./spy_matchers');

var _spy_matchers2 = _interopRequireDefault(_spy_matchers);

var _to_throw_matchers = require('./to_throw_matchers');

var _to_throw_matchers2 = _interopRequireDefault(_to_throw_matchers);

var _jasmine_utils = require('./jasmine_utils');

var _asymmetric_matchers = require('./asymmetric_matchers');

var _jest_matchers_object = require('./jest_matchers_object');

var _extract_expected_assertions_errors = require('./extract_expected_assertions_errors');

var _extract_expected_assertions_errors2 = _interopRequireDefault(
  _extract_expected_assertions_errors
=======
Object.defineProperty(exports, '__esModule', {
  value: true
});
Object.defineProperty(exports, 'AsymmetricMatcher', {
  enumerable: true,
  get: function () {
    return _asymmetricMatchers.AsymmetricMatcher;
  }
});
exports.expect = exports.default = exports.JestAssertionError = void 0;
var _expectUtils = require('@jest/expect-utils');
var matcherUtils = _interopRequireWildcard(require('jest-matcher-utils'));
var _jestUtil = require('jest-util');
var _asymmetricMatchers = require('./asymmetricMatchers');
var _extractExpectedAssertionsErrors = _interopRequireDefault(
  require('./extractExpectedAssertionsErrors')
>>>>>>> 74277b58428b76b5d4577f14d767a83dccdacaf2
);
var _jestMatchersObject = require('./jestMatchersObject');
var _matchers = _interopRequireDefault(require('./matchers'));
var _spyMatchers = _interopRequireDefault(require('./spyMatchers'));
var _toThrowMatchers = _interopRequireWildcard(require('./toThrowMatchers'));
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {default: obj};
}
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== 'function') return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
<<<<<<< HEAD
  } else {
    var newObj = {};
    if (obj != null) {
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key))
          newObj[key] = obj[key];
=======
  }
  if (obj === null || (typeof obj !== 'object' && typeof obj !== 'function')) {
    return {default: obj};
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {};
  var hasPropertyDescriptor =
    Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== 'default' && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor
        ? Object.getOwnPropertyDescriptor(obj, key)
        : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
>>>>>>> 74277b58428b76b5d4577f14d767a83dccdacaf2
      }
    }
  }
<<<<<<< HEAD
}

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *
 */

class JestAssertionError extends Error {}

const isPromise = obj =>
  !!obj &&
  (typeof obj === 'object' || typeof obj === 'function') &&
  typeof obj.then === 'function';

const createToThrowErrorMatchingSnapshotMatcher = function(matcher) {
  return function(received, testNameOrInlineSnapshot) {
=======
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
var Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;
var Symbol = globalThis['jest-symbol-do-not-touch'] || globalThis.Symbol;
var Promise =
  globalThis[Symbol.for('jest-native-promise')] || globalThis.Promise;
class JestAssertionError extends Error {
  matcherResult;
}
exports.JestAssertionError = JestAssertionError;
const createToThrowErrorMatchingSnapshotMatcher = function (matcher) {
  return function (received, testNameOrInlineSnapshot) {
>>>>>>> 74277b58428b76b5d4577f14d767a83dccdacaf2
    return matcher.apply(this, [received, testNameOrInlineSnapshot, true]);
  };
};
const getPromiseMatcher = (name, matcher) => {
  if (name === 'toThrow' || name === 'toThrowError') {
    return (0, _to_throw_matchers.createMatcher)('.' + name, true);
  } else if (
    name === 'toThrowErrorMatchingSnapshot' ||
    name === 'toThrowErrorMatchingInlineSnapshot'
  ) {
    return createToThrowErrorMatchingSnapshotMatcher(matcher);
  }
  return null;
};
<<<<<<< HEAD

const expect = function(actual) {
  if ((arguments.length <= 1 ? 0 : arguments.length - 1) !== 0) {
    throw new Error('Expect takes at most one argument.');
  }

  const allMatchers = (0, _jest_matchers_object.getMatchers)();
=======
const expect = (actual, ...rest) => {
  if (rest.length !== 0) {
    throw new Error('Expect takes at most one argument.');
  }
  const allMatchers = (0, _jestMatchersObject.getMatchers)();
>>>>>>> 74277b58428b76b5d4577f14d767a83dccdacaf2
  const expectation = {
    not: {},
    rejects: {not: {}},
    resolves: {not: {}}
  };

  const err = new JestAssertionError();

  Object.keys(allMatchers).forEach(name => {
    const matcher = allMatchers[name];
    const promiseMatcher = getPromiseMatcher(name, matcher) || matcher;
    expectation[name] = makeThrowingMatcher(matcher, false, actual);
    expectation.not[name] = makeThrowingMatcher(matcher, true, actual);

    expectation.resolves[name] = makeResolveMatcher(
      name,
      promiseMatcher,
      false,
      actual,
      err
    );
    expectation.resolves.not[name] = makeResolveMatcher(
      name,
      promiseMatcher,
      true,
      actual,
      err
    );

    expectation.rejects[name] = makeRejectMatcher(
      name,
      promiseMatcher,
      false,
      actual,
      err
    );
    expectation.rejects.not[name] = makeRejectMatcher(
      name,
      promiseMatcher,
      true,
      actual,
      err
    );
  });

  return expectation;
};
exports.expect = expect;
const getMessage = message =>
  (message && message()) ||
  matcherUtils.RECEIVED_COLOR('No message was specified for this matcher.');
<<<<<<< HEAD

const makeResolveMatcher = (matcherName, matcher, isNot, actual, outerErr) =>
  function() {
    for (
      var _len = arguments.length, args = Array(_len), _key = 0;
      _key < _len;
      _key++
    ) {
      args[_key] = arguments[_key];
    }

    const matcherStatement = `.resolves.${isNot ? 'not.' : ''}${matcherName}`;
    if (!isPromise(actual)) {
      throw new JestAssertionError(
        matcherUtils.matcherHint(matcherStatement, 'received', '') +
          '\n\n' +
          `${matcherUtils.RECEIVED_COLOR(
            'received'
          )} value must be a Promise.\n` +
          matcherUtils.printWithType(
            'Received',
            actual,
            matcherUtils.printReceived
          )
      );
    }

    const innerErr = new JestAssertionError();

    return actual.then(
      result =>
        makeThrowingMatcher(matcher, isNot, result, innerErr).apply(null, args),
      reason => {
        outerErr.message =
          matcherUtils.matcherHint(matcherStatement, 'received', '') +
          '\n\n' +
          `Expected ${matcherUtils.RECEIVED_COLOR(
            'received'
          )} Promise to resolve, ` +
          'instead it rejected to value\n' +
          `  ${matcherUtils.printReceived(reason)}`;
        return Promise.reject(outerErr);
      }
    );
  };

const makeRejectMatcher = (matcherName, matcher, isNot, actual, outerErr) =>
  function() {
    for (
      var _len2 = arguments.length, args = Array(_len2), _key2 = 0;
      _key2 < _len2;
      _key2++
    ) {
      args[_key2] = arguments[_key2];
    }

    const matcherStatement = `.rejects.${isNot ? 'not.' : ''}${matcherName}`;
    if (!isPromise(actual)) {
      throw new JestAssertionError(
        matcherUtils.matcherHint(matcherStatement, 'received', '') +
          '\n\n' +
          `${matcherUtils.RECEIVED_COLOR(
            'received'
          )} value must be a Promise.\n` +
          matcherUtils.printWithType(
            'Received',
            actual,
            matcherUtils.printReceived
          )
      );
    }

    const innerErr = new JestAssertionError();

    return actual.then(
      result => {
        outerErr.message =
          matcherUtils.matcherHint(matcherStatement, 'received', '') +
          '\n\n' +
          `Expected ${matcherUtils.RECEIVED_COLOR(
            'received'
          )} Promise to reject, ` +
          'instead it resolved to value\n' +
          `  ${matcherUtils.printReceived(result)}`;
        return Promise.reject(outerErr);
      },
      reason =>
        makeThrowingMatcher(matcher, isNot, reason, innerErr).apply(null, args)
    );
  };

const makeThrowingMatcher = (matcher, isNot, actual, err) =>
  function throwingMatcher() {
    let throws = true;
    const utils = Object.assign({}, matcherUtils, {
      iterableEquality: _utils.iterableEquality,
      subsetEquality: _utils.subsetEquality
    });

    const matcherContext = Object.assign(
=======
const makeResolveMatcher =
  (matcherName, matcher, isNot, actual, outerErr) =>
  (...args) => {
    const options = {
      isNot,
      promise: 'resolves'
    };
    if (!(0, _jestUtil.isPromise)(actual)) {
      throw new JestAssertionError(
        matcherUtils.matcherErrorMessage(
          matcherUtils.matcherHint(matcherName, undefined, '', options),
          `${matcherUtils.RECEIVED_COLOR('received')} value must be a promise`,
          matcherUtils.printWithType(
            'Received',
            actual,
            matcherUtils.printReceived
          )
        )
      );
    }
    const innerErr = new JestAssertionError();
    return actual.then(
      result =>
        makeThrowingMatcher(matcher, isNot, 'resolves', result, innerErr).apply(
          null,
          args
        ),
      reason => {
        outerErr.message =
          `${matcherUtils.matcherHint(
            matcherName,
            undefined,
            '',
            options
          )}\n\n` +
          'Received promise rejected instead of resolved\n' +
          `Rejected to value: ${matcherUtils.printReceived(reason)}`;
        return Promise.reject(outerErr);
      }
    );
  };
const makeRejectMatcher =
  (matcherName, matcher, isNot, actual, outerErr) =>
  (...args) => {
    const options = {
      isNot,
      promise: 'rejects'
    };
    const actualWrapper = typeof actual === 'function' ? actual() : actual;
    if (!(0, _jestUtil.isPromise)(actualWrapper)) {
      throw new JestAssertionError(
        matcherUtils.matcherErrorMessage(
          matcherUtils.matcherHint(matcherName, undefined, '', options),
          `${matcherUtils.RECEIVED_COLOR(
            'received'
          )} value must be a promise or a function returning a promise`,
          matcherUtils.printWithType(
            'Received',
            actual,
            matcherUtils.printReceived
          )
        )
      );
    }
    const innerErr = new JestAssertionError();
    return actualWrapper.then(
      result => {
        outerErr.message =
          `${matcherUtils.matcherHint(
            matcherName,
            undefined,
            '',
            options
          )}\n\n` +
          'Received promise resolved instead of rejected\n' +
          `Resolved to value: ${matcherUtils.printReceived(result)}`;
        return Promise.reject(outerErr);
      },
      reason =>
        makeThrowingMatcher(matcher, isNot, 'rejects', reason, innerErr).apply(
          null,
          args
        )
    );
  };
const makeThrowingMatcher = (matcher, isNot, promise, actual, err) =>
  function throwingMatcher(...args) {
    let throws = true;
    const utils = {
      ...matcherUtils,
      iterableEquality: _expectUtils.iterableEquality,
      subsetEquality: _expectUtils.subsetEquality
    };
    const matcherUtilsThing = {
      customTesters: (0, _jestMatchersObject.getCustomEqualityTesters)(),
>>>>>>> 74277b58428b76b5d4577f14d767a83dccdacaf2
      // When throws is disabled, the matcher will not throw errors during test
      // execution but instead add them to the global matcher state. If a
      // matcher throws, test execution is normally stopped immediately. The
      // snapshot matcher uses it because we want to log all snapshot
      // failures in a test.
<<<<<<< HEAD
      {dontThrow: () => (throws = false)},
      (0, _jest_matchers_object.getState)(),
      {
        equals: _jasmine_utils.equals,
        error: err,
        isNot: isNot,
        utils: utils
      }
    );

    const processResult = result => {
      _validateResult(result);

      (0, _jest_matchers_object.getState)().assertionCalls++;

=======
      dontThrow: () => (throws = false),
      equals: _expectUtils.equals,
      utils
    };
    const matcherContext = {
      ...(0, _jestMatchersObject.getState)(),
      ...matcherUtilsThing,
      error: err,
      isNot,
      promise
    };
    const processResult = (result, asyncError) => {
      _validateResult(result);
      (0, _jestMatchersObject.getState)().assertionCalls++;
>>>>>>> 74277b58428b76b5d4577f14d767a83dccdacaf2
      if ((result.pass && isNot) || (!result.pass && !isNot)) {
        // XOR
        const message = getMessage(result.message);
        let error;
        if (err) {
          error = err;
          error.message = message;
        } else {
          error = new JestAssertionError(message);

          // Try to remove this function from the stack trace frame.
          // Guard for some environments (browsers) that do not support this feature.
          if (Error.captureStackTrace) {
            Error.captureStackTrace(error, throwingMatcher);
          }
        }
        // Passing the result of the matcher with the error so that a custom
        // reporter could access the actual and expected objects of the result
        // for example in order to display a custom visual diff
<<<<<<< HEAD
        error.matcherResult = result;

=======
        error.matcherResult = {
          ...result,
          message
        };
>>>>>>> 74277b58428b76b5d4577f14d767a83dccdacaf2
        if (throws) {
          throw error;
        } else {
          (0, _jest_matchers_object.getState)().suppressedErrors.push(error);
        }
      } else {
        (0, _jestMatchersObject.getState)().numPassingAsserts++;
      }
    };
    const handleError = error => {
      if (
        matcher[_jest_matchers_object.INTERNAL_MATCHER_FLAG] === true &&
        !(error instanceof JestAssertionError) &&
        error.name !== 'PrettyFormatPluginError' &&
        // Guard for some environments (browsers) that do not support this feature.
        Error.captureStackTrace
      ) {
        // Try to remove this and deeper functions from the stack trace frame.
        Error.captureStackTrace(error, throwingMatcher);
      }
      throw error;
    };
    let potentialResult;
    try {
<<<<<<< HEAD
      for (
        var _len3 = arguments.length, args = Array(_len3), _key3 = 0;
        _key3 < _len3;
        _key3++
      ) {
        args[_key3] = arguments[_key3];
      }

      potentialResult = matcher.apply(matcherContext, [actual].concat(args));

      if (isPromise(potentialResult)) {
        const asyncResult = potentialResult;

        return asyncResult
          .then(aResult => processResult(aResult))
          .catch(error => handlError(error));
      } else {
        const syncResult = potentialResult;

        return processResult(syncResult);
=======
      potentialResult =
        matcher[_jestMatchersObject.INTERNAL_MATCHER_FLAG] === true
          ? matcher.call(matcherContext, actual, ...args)
          : // It's a trap specifically for inline snapshot to capture this name
            // in the stack trace, so that it can correctly get the custom matcher
            // function call.
            (function __EXTERNAL_MATCHER_TRAP__() {
              return matcher.call(matcherContext, actual, ...args);
            })();
      if ((0, _jestUtil.isPromise)(potentialResult)) {
        const asyncError = new JestAssertionError();
        if (Error.captureStackTrace) {
          Error.captureStackTrace(asyncError, throwingMatcher);
        }
        return potentialResult
          .then(aResult => processResult(aResult, asyncError))
          .catch(handleError);
      } else {
        return processResult(potentialResult);
>>>>>>> 74277b58428b76b5d4577f14d767a83dccdacaf2
      }
    } catch (error) {
      return handleError(error);
    }
  };
expect.extend = matchers =>
<<<<<<< HEAD
  (0, _jest_matchers_object.setMatchers)(matchers, false, expect);

expect.anything = _asymmetric_matchers.anything;
expect.any = _asymmetric_matchers.any;

expect.not = {
  arrayContaining: _asymmetric_matchers.arrayNotContaining,
  objectContaining: _asymmetric_matchers.objectNotContaining,
  stringContaining: _asymmetric_matchers.stringNotContaining,
  stringMatching: _asymmetric_matchers.stringNotMatching
};

expect.objectContaining = _asymmetric_matchers.objectContaining;
expect.arrayContaining = _asymmetric_matchers.arrayContaining;
expect.stringContaining = _asymmetric_matchers.stringContaining;
expect.stringMatching = _asymmetric_matchers.stringMatching;

=======
  (0, _jestMatchersObject.setMatchers)(matchers, false, expect);
expect.addEqualityTesters = customTesters =>
  (0, _jestMatchersObject.addCustomEqualityTesters)(customTesters);
expect.anything = _asymmetricMatchers.anything;
expect.any = _asymmetricMatchers.any;
expect.not = {
  arrayContaining: _asymmetricMatchers.arrayNotContaining,
  closeTo: _asymmetricMatchers.notCloseTo,
  objectContaining: _asymmetricMatchers.objectNotContaining,
  stringContaining: _asymmetricMatchers.stringNotContaining,
  stringMatching: _asymmetricMatchers.stringNotMatching
};
expect.arrayContaining = _asymmetricMatchers.arrayContaining;
expect.closeTo = _asymmetricMatchers.closeTo;
expect.objectContaining = _asymmetricMatchers.objectContaining;
expect.stringContaining = _asymmetricMatchers.stringContaining;
expect.stringMatching = _asymmetricMatchers.stringMatching;
>>>>>>> 74277b58428b76b5d4577f14d767a83dccdacaf2
const _validateResult = result => {
  if (
    typeof result !== 'object' ||
    typeof result.pass !== 'boolean' ||
    (result.message &&
      typeof result.message !== 'string' &&
      typeof result.message !== 'function')
  ) {
    throw new Error(
      'Unexpected return from a matcher function.\n' +
        'Matcher functions should ' +
        'return an object in the following format:\n' +
        '  {message?: string | function, pass: boolean}\n' +
        `'${matcherUtils.stringify(result)}' was returned`
    );
  }
};
function assertions(expected) {
  const error = new Error();
  if (Error.captureStackTrace) {
    Error.captureStackTrace(error, assertions);
  }
<<<<<<< HEAD

  (0, _jest_matchers_object.getState)().expectedAssertionsNumber = expected;
  (0, _jest_matchers_object.getState)().expectedAssertionsNumberError = error;
}
function hasAssertions() {
=======
  (0, _jestMatchersObject.setState)({
    expectedAssertionsNumber: expected,
    expectedAssertionsNumberError: error
  });
}
function hasAssertions(...args) {
>>>>>>> 74277b58428b76b5d4577f14d767a83dccdacaf2
  const error = new Error();
  if (Error.captureStackTrace) {
    Error.captureStackTrace(error, hasAssertions);
  }
<<<<<<< HEAD

  matcherUtils.ensureNoExpected(
    arguments.length <= 0 ? undefined : arguments[0],
    '.hasAssertions'
  );
  (0, _jest_matchers_object.getState)().isExpectingAssertions = true;
  (0, _jest_matchers_object.getState)().isExpectingAssertionsError = error;
}

// add default jest matchers
(0, _jest_matchers_object.setMatchers)(_matchers2.default, true, expect);
(0, _jest_matchers_object.setMatchers)(_spy_matchers2.default, true, expect);
(0, _jest_matchers_object.setMatchers)(
  _to_throw_matchers2.default,
  true,
  expect
);

expect.addSnapshotSerializer = () => void 0;
=======
  matcherUtils.ensureNoExpected(args[0], '.hasAssertions');
  (0, _jestMatchersObject.setState)({
    isExpectingAssertions: true,
    isExpectingAssertionsError: error
  });
}

// add default jest matchers
(0, _jestMatchersObject.setMatchers)(_matchers.default, true, expect);
(0, _jestMatchersObject.setMatchers)(_spyMatchers.default, true, expect);
(0, _jestMatchersObject.setMatchers)(_toThrowMatchers.default, true, expect);
>>>>>>> 74277b58428b76b5d4577f14d767a83dccdacaf2
expect.assertions = assertions;
expect.hasAssertions = hasAssertions;
expect.getState = _jest_matchers_object.getState;
expect.setState = _jest_matchers_object.setState;
expect.extractExpectedAssertionsErrors =
<<<<<<< HEAD
  _extract_expected_assertions_errors2.default;

module.exports = expect;
=======
  _extractExpectedAssertionsErrors.default;
var _default = expect;
exports.default = _default;
>>>>>>> 74277b58428b76b5d4577f14d767a83dccdacaf2
